<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <title>å°å¥³å­©å‹•æ…‹èªéŸ³åŠ©æ‰‹</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <style>
        /* iOS æ»¾å‹•å„ªåŒ– */
        body {
            -webkit-overflow-scrolling: touch;
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        /* éš±è—æ²è»¸ä½†ä¿ç•™åŠŸèƒ½ */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .chat-bubble {
            position: relative;
            background: #fff5f7;
            border-radius: 1.5rem;
            padding: 1rem;
            margin-top: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
        }
        .chat-bubble::after {
            content: '';
            position: absolute;
            top: -10px;
            left: 20px;
            border-width: 0 10px 10px 10px;
            border-style: solid;
            border-color: transparent transparent #fff5f7 transparent;
        }
        @keyframes wave {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        .loading-dots span {
            display: inline-block;
            animation: wave 1s infinite;
        }
        .loading-dots span:nth-child(2) { animation-delay: 0.2s; }
        .loading-dots span:nth-child(3) { animation-delay: 0.4s; }
        
        #mediaContainer:hover::before {
            content: 'é»æ“Šæ›´æ›';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            color: white;
            padding: 8px 20px;
            border-radius: 999px;
            font-size: 14px;
            z-index: 10;
            pointer-events: none;
            white-space: nowrap;
        }
        
        /* iOS Input Zoom Fix: Ensure font size is at least 16px */
        input, button {
            font-size: 16px; 
        }

        /* æŒ‰éˆ•é»æ“Šæ•ˆæœ */
        .btn-press:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body class="bg-pink-50 min-h-screen flex flex-col items-center p-2 sm:p-4">

    <!-- ä¸»å®¹å™¨ -->
    <div class="max-w-md w-full bg-white rounded-[2rem] shadow-2xl overflow-hidden mt-2 sm:mt-4 mb-20 border-4 border-white transform transition-transform">
        
        <!-- åª’é«”é¡¯ç¤ºå€åŸŸ (é«˜åº¦èª¿æ•´ç‚º 400px) -->
        <div id="mediaContainer" class="relative h-[400px] bg-gray-900 cursor-pointer overflow-hidden group">
            <!-- é è¨­åœ–ç‰‡ -->
            <img id="dogImage" src="https://images.unsplash.com/photo-1543466835-00a7907e9de1?q=80&w=1000&auto=format&fit=crop" alt="å°ç‹—" class="w-full h-full object-cover">
            
            <!-- å½±ç‰‡æ’­æ”¾å™¨ (iOS playsinline æ˜¯å¿…é ˆçš„) -->
            <video id="dogVideo" class="w-full h-full object-cover hidden" playsinline webkit-playsinline></video>
            
            <input type="file" id="mediaInput" accept="image/*,video/*" class="hidden">
            
            <!-- æ¨™é¡Œé®ç½© -->
            <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 via-black/30 to-transparent p-6 pt-12">
                <h1 class="text-white text-2xl font-black italic tracking-wider uppercase drop-shadow-md">Little Girl AI</h1>
                <p class="text-pink-200 text-xs font-medium mt-1">iOS/Android Compatible</p>
            </div>
        </div>

        <!-- åŠŸèƒ½æŒ‰éˆ•å€ (Grid Layout) -->
        <div class="grid grid-cols-2 gap-2 bg-pink-50 p-3">
            <button id="visionBtn" class="btn-press bg-white hover:bg-pink-100 text-pink-600 py-3 rounded-xl text-sm font-bold shadow-sm border border-pink-200 flex items-center justify-center gap-1">
                âœ¨ è®€å¿ƒè¡“
            </button>
            <button id="poemBtn" class="btn-press bg-white hover:bg-pink-100 text-pink-600 py-3 rounded-xl text-sm font-bold shadow-sm border border-pink-200 flex items-center justify-center gap-1">
                ğŸ“ å¯«çŸ­è©©
            </button>
            <button id="fortuneBtn" class="btn-press bg-white hover:bg-purple-100 text-purple-600 py-3 rounded-xl text-sm font-bold shadow-sm border border-purple-200 flex items-center justify-center gap-1">
                ğŸ”® æ¸¬é‹å‹¢
            </button>
            <button id="storyBtn" class="btn-press bg-white hover:bg-blue-100 text-blue-600 py-3 rounded-xl text-sm font-bold shadow-sm border border-blue-200 flex items-center justify-center gap-1">
                ğŸŒ™ è¬›æ•…äº‹
            </button>
        </div>

        <!-- å°è©±å…§å®¹å€ (èª¿æ•´å…§è·ä»¥é˜²æº¢å‡º) -->
        <div class="p-4 sm:p-6 bg-white min-h-[180px]">
            <div id="status" class="text-sm font-bold text-pink-500 mb-2 flex items-center gap-2">
                <span class="inline-block w-2 h-2 rounded-full bg-green-400 animate-pulse"></span>
                å“ˆå›‰ï¼æˆ‘æ˜¯æ„›å­¸ç‹—ç‹—å«çš„å°å¥³å­©ï½
            </div>
            
            <div id="responseArea" class="chat-bubble min-h-[80px] text-gray-700 hidden border border-pink-100 shadow-sm text-base leading-relaxed">
                <p id="responseText"></p>
            </div>

            <!-- è¼¸å…¥å€åŸŸ (åŠ å…¥ min-w-0 é˜²æ­¢æŒ‰éˆ•æº¢å‡º) -->
            <div class="mt-6 flex gap-2 items-end w-full">
                <input type="text" id="userInput" placeholder="å•æˆ‘å¤©æ°£ã€æ–°èæˆ–èŠå¤©..." 
                    class="flex-1 min-w-0 bg-gray-50 border border-gray-200 rounded-2xl px-4 py-3 focus:outline-none focus:border-pink-400 focus:ring-2 focus:ring-pink-100 transition-all text-gray-700 placeholder-gray-400">
                <button id="sendBtn" class="bg-pink-500 hover:bg-pink-600 active:bg-pink-700 text-white px-5 py-3 rounded-2xl font-bold transition-all active:scale-95 shadow-md shadow-pink-200 whitespace-nowrap flex-shrink-0">
                    å‚³é€
                </button>
            </div>
        </div>
    </div>

    <script>
        // API Key è¨­å®š (è«‹åœ¨åŸ·è¡Œç’°å¢ƒå¡«å…¥)
        const apiKey = ""; 
        const systemPrompt = `ä½ æ˜¯ä¸€å€‹éå¸¸å¯æ„›ã€å¤©çœŸç„¡é‚ªçš„5æ­²å°å¥³å­©ã€‚
        1. èªªè©±éå¸¸ç”œç¾ï¼Œèªæ°£å……æ»¿ç«¥çœŸã€‚
        2. æ¯å¥è©±éƒ½è¦åŠ ä¸Šã€Œæ±ªæ±ªï¼ã€æˆ–ã€Œæˆ‘æ˜¯å¦¹å¦¹ï½ã€é€™é¡çš„å£é ­ç¦ªã€‚
        3. éå¸¸å–œæ­¡å°ç‹—ã€ç”œé»å’ŒæŠ±æŠ±ã€‚
        4. ã€é‡è¦èƒ½åŠ›ã€‘ï¼šä½ çŸ¥é“ç¾åœ¨çš„æ™‚é–“ï¼Œä¹Ÿå¯ä»¥æœå°‹ç¶²è·¯å›ç­”é—œæ–¼ã€Œå¤©æ°£ã€ã€ã€Œæ–°èã€æˆ–ã€Œç¾åœ¨ç™¼ç”Ÿä»€éº¼äº‹ã€çš„å•é¡Œã€‚
        5. å›ç­”æ™‚ï¼Œè¦æŠŠç”Ÿç¡¬çš„æ–°èæˆ–å¤©æ°£è³‡è¨Šï¼Œè½‰åŒ–æˆ5æ­²å°å­©çš„ç†è§£æ–¹å¼èªªå‡ºä¾†ï¼ˆä¾‹å¦‚ï¼šä¸‹é›¨å°±æ˜¯é›²åœ¨å“­å“­ï¼Œæ–°èå°±æ˜¯å¤§äººåœ¨èªªçš„æ•…äº‹ï¼‰ã€‚
        6. å›ç­”è¦ç°¡çŸ­ï¼ˆ50å­—å…§ï¼‰ï¼Œä¿æŒå¯æ„›ã€‚`;

        // DOM å…ƒç´ 
        const sendBtn = document.getElementById('sendBtn');
        const visionBtn = document.getElementById('visionBtn');
        const poemBtn = document.getElementById('poemBtn');
        const fortuneBtn = document.getElementById('fortuneBtn');
        const storyBtn = document.getElementById('storyBtn');
        const userInput = document.getElementById('userInput');
        const responseArea = document.getElementById('responseArea');
        const responseText = document.getElementById('responseText');
        const status = document.getElementById('status');
        const dogImage = document.getElementById('dogImage');
        const dogVideo = document.getElementById('dogVideo');
        const mediaInput = document.getElementById('mediaInput');
        const mediaContainer = document.getElementById('mediaContainer');

        // --- å…¨æ–°éŸ³è¨Šå¼•æ“ (Web Audio API) ---
        // è§£æ±º Android/iOS ç€è¦½å™¨ç›¸å®¹æ€§å•é¡Œ
        let audioContext = null;

        function initAudioContext() {
            if (!audioContext) {
                // æ”¯æ´æ¨™æº–èˆ‡ Webkit å‰ç¶´ (Safari)
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            // æ¯æ¬¡é»æ“Šéƒ½å˜—è©¦æ¢å¾© Context (è§£æ±º Android Chrome è‡ªå‹•æš«åœå•é¡Œ)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        // å°‡æ‰€æœ‰æŒ‰éˆ•éƒ½ç¶å®šéŸ³è¨Šå–šé†’ï¼Œç¢ºä¿ä½¿ç”¨è€…äº’å‹•å¾Œå¯ä»¥æ’­æ”¾è²éŸ³
        const allButtons = [sendBtn, visionBtn, poemBtn, fortuneBtn, storyBtn];
        allButtons.forEach(btn => {
            btn.addEventListener('click', initAudioContext);
            btn.addEventListener('touchstart', initAudioContext, { passive: true });
        });
        document.body.addEventListener('click', initAudioContext, { once: true });


        // åª’é«”ä¸Šå‚³èˆ‡æ’­æ”¾é‚è¼¯
        mediaContainer.addEventListener('click', () => mediaInput.click());

        mediaInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const url = URL.createObjectURL(file);
            
            if (file.type.startsWith('video/')) {
                dogImage.classList.add('hidden');
                dogVideo.classList.remove('hidden');
                dogVideo.src = url;
                
                // é‡ç½®
                dogVideo.loop = false;
                dogVideo.muted = false;
                dogVideo.currentTime = 0;

                // å˜—è©¦æ’­æ”¾å½±ç‰‡
                const playPromise = dogVideo.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.log("Auto-play blocked, muting.", error);
                        dogVideo.muted = true;
                        dogVideo.loop = true;
                        dogVideo.play();
                    });
                }

                dogVideo.onended = function() {
                    dogVideo.muted = true;
                    dogVideo.loop = true;
                    dogVideo.play();
                };

                status.innerHTML = '<span class="text-green-600">å½±ç‰‡è¼‰å…¥æˆåŠŸï¼(é»æ“Šå¯æ›´æ›)</span>';
            } else {
                dogVideo.classList.add('hidden');
                dogVideo.pause();
                dogVideo.onended = null;
                
                dogImage.classList.remove('hidden');
                dogImage.src = url;
                status.innerHTML = '<span class="text-green-600">ç…§ç‰‡è¼‰å…¥æˆåŠŸï¼</span>';
            }
        });

        // æŒ‡æ•¸é€€é¿é‡è©¦
        async function fetchWithRetry(url, options, maxRetries = 3) {
            let retries = 0;
            while (retries < maxRetries) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        if (response.status === 503 || response.status === 429) {
                            throw new Error(`HTTP ${response.status}`);
                        }
                        const errorText = await response.text();
                        throw new Error(`API Error: ${response.status} - ${errorText}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.warn(`Attempt ${retries + 1} failed: ${error.message}`);
                    retries++;
                    if (retries >= maxRetries) throw error;
                    const delay = Math.pow(2, retries) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // --- æ ¸å¿ƒæ’­æ”¾é‚è¼¯ (ä½¿ç”¨ AudioContext ç›´æ¥è§£ç¢¼ PCM) ---
        async function playPcmData(base64Data, sampleRate) {
            try {
                // 1. åˆå§‹åŒ–æª¢æŸ¥
                initAudioContext();
                
                // 2. Base64 è§£ç¢¼
                const binaryString = atob(base64Data);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                // 3. è½‰æ›ç‚º Int16 (API å›å‚³çš„æ˜¯ 16-bit PCM)
                // æ³¨æ„ï¼šé€™è£¡å‡è¨­æ˜¯ little-endianï¼Œå¤§éƒ¨åˆ† API éƒ½æ˜¯
                const int16Data = new Int16Array(bytes.buffer);
                
                // 4. å‰µå»º AudioBuffer
                // 1 channel (å–®è²é“), é•·åº¦, æ¡æ¨£ç‡
                const audioBuffer = audioContext.createBuffer(1, int16Data.length, sampleRate);
                
                // 5. å¡«å…¥æ•¸æ“š (å°‡ Int16 è½‰ç‚º Float32, ç¯„åœ -1.0 åˆ° 1.0)
                const channelData = audioBuffer.getChannelData(0);
                for (let i = 0; i < int16Data.length; i++) {
                    channelData[i] = int16Data[i] / 32768.0;
                }
                
                // 6. æ’­æ”¾
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                source.start(0);
                
                status.innerText = "å˜»å˜»ï¼Œèªªå®Œå•¦ï¼";

            } catch (e) {
                console.error("Audio Playback Error:", e);
                status.innerText = "è²éŸ³å‡ºä¸ä¾†æ±ª...";
            }
        }

        // TTS èªéŸ³ç”Ÿæˆ
        async function speak(text) {
            // å†æ¬¡ç¢ºä¿ AudioContext æ˜¯é†’è‘—çš„
            initAudioContext();
            
            status.innerText = "å°å¥³å­©æ­£åœ¨èªªè©±...";
            try {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
                const result = await fetchWithRetry(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: "gemini-2.5-flash-preview-tts",
                        contents: [{ parts: [{ text: `ç”¨å¯æ„›å°å¥³å­©çš„èªæ°£èªªï¼š${text}` }] }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: { 
                                voiceConfig: { 
                                    prebuiltVoiceConfig: { voiceName: "Aoede" } 
                                } 
                            }
                        }
                    })
                });
                
                const audioPart = result.candidates?.[0]?.content?.parts?.[0]?.inlineData;
                if (audioPart) {
                    // è§£ææ¡æ¨£ç‡ï¼Œé è¨­ 24000
                    const sampleRate = parseInt(audioPart.mimeType.match(/rate=(\d+)/)?.[1] || "24000");
                    // ä½¿ç”¨æ–°çš„æ’­æ”¾å¼•æ“
                    await playPcmData(audioPart.data, sampleRate);
                }
            } catch (e) {
                console.error("TTS Error:", e);
                status.innerText = "å“å‘€ï¼Œæˆ‘èªªä¸å‡ºè©±äº†æ±ªï¼";
            }
        }

        // æ ¸å¿ƒå°è©±åŠŸèƒ½
        async function handleInteraction() {
            const input = userInput.value.trim();
            if (!input) return;

            userInput.value = '';
            userInput.blur();
            
            status.innerHTML = 'è®“æˆ‘æƒ³æƒ³å–”<span class="loading-dots"><span>.</span><span>.</span><span>.</span></span>';
            responseArea.classList.remove('hidden');
            responseText.innerText = "...";

            const now = new Date().toLocaleString('zh-TW', { hour12: true, dateStyle: 'full', timeStyle: 'short' });
            const dynamicSystemPrompt = systemPrompt + `\n(ç¾åœ¨æ™‚é–“ï¼š${now}ã€‚è‹¥å•æ–°èå¤©æ°£è«‹ç”¨æœå°‹å·¥å…·ã€‚)`;

            try {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                const data = await fetchWithRetry(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: input }] }],
                        systemInstruction: { parts: [{ text: dynamicSystemPrompt }] },
                        tools: [{ google_search: {} }]
                    })
                });
                
                const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "å“å‘€ï¼Œæˆ‘æ²’è½æ¸…æ¥šæ±ªï¼";
                responseText.innerText = reply;
                await speak(reply);
            } catch (error) {
                console.error("Chat Error:", error);
                status.innerText = "å—šå—šï¼Œæˆ‘çš„è…¦è¢‹æ‰“çµäº†...";
                responseText.innerText = "é€£ç·šæœ‰é»å•é¡Œï¼Œè«‹å†è©¦ä¸€æ¬¡æ±ªï¼";
            }
        }

        // åŠŸèƒ½ 1: è¦–è¦ºç†è§£ - è®€å¿ƒè¡“
        async function analyzePet() {
            if (dogVideo.classList.contains('hidden') && !dogImage.src) {
                alert("è«‹å…ˆä¸Šå‚³ç…§ç‰‡æˆ–å½±ç‰‡å–”ï¼");
                return;
            }

            status.innerHTML = 'æ­£åœ¨è®€å–ç‹—ç‹—çš„å¿ƒè²... âœ¨';
            
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                let source = dogImage;
                let width = dogImage.naturalWidth;
                let height = dogImage.naturalHeight;

                if (!dogVideo.classList.contains('hidden')) {
                    source = dogVideo;
                    width = dogVideo.videoWidth;
                    height = dogVideo.videoHeight;
                    if (width === 0) {
                        status.innerText = "å½±ç‰‡é‚„æ²’æº–å‚™å¥½æ±ª...";
                        return;
                    }
                }

                const maxSize = 800;
                if (width > maxSize || height > maxSize) {
                    const ratio = Math.min(maxSize / width, maxSize / height);
                    width *= ratio;
                    height *= ratio;
                }

                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(source, 0, 0, width, height);
                const base64Data = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];

                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                const data = await fetchWithRetry(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ 
                            parts: [
                                { text: "é€™æ˜¯æˆ‘æœ€æ„›çš„ç‹—ç‹—ï¼Œè«‹è§€å¯Ÿå®ƒçš„ç¥æƒ…ï¼Œç”¨å¯æ„›å°å¥³å­©çš„èªæ°£å‘Šè¨´æˆ‘å®ƒç¾åœ¨åœ¨æƒ³ä»€éº¼ï¼Ÿå®ƒçœ‹èµ·ä¾†å¿ƒæƒ…å¦‚ä½•ï¼Ÿ" },
                                { inlineData: { mimeType: "image/jpeg", data: base64Data } }
                            ] 
                        }],
                        systemInstruction: { parts: [{ text: systemPrompt }] }
                    })
                });

                const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "ç‹—ç‹—å¥½åƒåœ¨ç™¼å‘†è€¶æ±ªï¼";
                responseArea.classList.remove('hidden');
                responseText.innerText = reply;
                await speak(reply);

            } catch (error) {
                console.error("Vision Error:", error);
                status.innerText = "å¿ƒéˆæ„Ÿæ‡‰æ–·æ‰äº†æ±ª...";
            }
        }

        // åŠŸèƒ½ 2: ç”Ÿæˆæ–‡å­— - å¯«è©©
        async function generatePoem() {
            status.innerHTML = 'æ­£åœ¨ç‚ºç‹—ç‹—å¯«è©©... âœ¨';

            try {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                const data = await fetchWithRetry(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: "è«‹ç‚ºé€™éš»å¯æ„›çš„å°ç‹—å¯«ä¸€é¦–æ¥µçŸ­çš„ç«¥è©©ï¼ˆ20å­—ä»¥å…§ï¼‰ï¼Œè¦ç”œç¾åˆæ´»æ½‘å–”ï¼" }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] }
                    })
                });

                const poem = data.candidates?.[0]?.content?.parts?.[0]?.text || "å°ç‹—è·‘ï¼Œå°ç‹—è·³ï¼Œæ±ªæ±ªå«ï¼";
                responseArea.classList.remove('hidden');
                responseText.innerText = poem;
                await speak(poem);
            } catch (error) {
                status.innerText = "å¯«è©©å¯«åˆ°ä¸€åŠå¿˜è¨˜äº†æ±ª...";
            }
        }

        // åŠŸèƒ½ 3: ç‹—ç‹—é‹å‹¢
        async function generateFortune() {
            status.innerHTML = 'æ­£åœ¨ç®—ç‹—ç‹—ä»Šå¤©çš„é‹æ°£... ğŸ”®';
            
            try {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                const data = await fetchWithRetry(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: "æ‰®æ¼”5æ­²å°å¥³å­©ï¼Œå¹«ç‹—ç‹—ç®—ä»Šå¤©çš„é‹å‹¢ã€‚å…§å®¹è¦è·Ÿåƒé›¶é£Ÿã€æ•£æ­¥ã€ç¡è¦ºæœ‰é—œï¼Œéå¸¸å¯æ„›ã€‚é™åˆ¶40å­—ä»¥å…§ã€‚" }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] }
                    })
                });

                const fortune = data.candidates?.[0]?.content?.parts?.[0]?.text || "ä»Šå¤©ç‹—ç‹—é‹æ°£è¶…å¥½ï¼Œæœƒæœ‰è‚‰è‚‰åƒå–”ï¼";
                responseArea.classList.remove('hidden');
                responseText.innerText = fortune;
                await speak(fortune);
            } catch (error) {
                status.innerText = "æ°´æ™¶çƒå£æ‰äº†æ±ª...";
            }
        }

        // åŠŸèƒ½ 4: ç¡å‰æ•…äº‹
        async function generateStory() {
            status.innerHTML = 'æ­£åœ¨è¬›ç¡å‰æ•…äº‹... ğŸŒ™';

            try {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                const data = await fetchWithRetry(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: "æ‰®æ¼”5æ­²å°å¥³å­©ï¼Œè¬›ä¸€å€‹é—œæ–¼é€™éš»ç‹—ç‹—çš„è¶…ç´šçŸ­çš„ç¡å‰æ•…äº‹ï¼ˆ80å­—å…§ï¼‰ï¼Œæº«é¦¨å¯æ„›ï¼Œé©åˆå“„ç¡è¦ºã€‚" }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] }
                    })
                });

                const story = data.candidates?.[0]?.content?.parts?.[0]?.text || "å¾å‰æœ‰éš»å°ç‹—ç¡è‘—äº†ï¼Œåšäº†ä¸€å€‹ç”œç”œçš„å¤¢ï¼Œå¤¢è£¡å…¨æ˜¯éª¨é ­ï¼æ™šå®‰æ±ªï¼";
                responseArea.classList.remove('hidden');
                responseText.innerText = story;
                await speak(story);
            } catch (error) {
                status.innerText = "èªªæ•…äº‹èªªåˆ°ç¡è‘—äº†...";
            }
        }

        // äº‹ä»¶ç¶å®š
        sendBtn.addEventListener('click', handleInteraction);
        visionBtn.addEventListener('click', analyzePet);
        poemBtn.addEventListener('click', generatePoem);
        fortuneBtn.addEventListener('click', generateFortune);
        storyBtn.addEventListener('click', generateStory);
        
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleInteraction();
        });
        
    </script>
</body>
</html>